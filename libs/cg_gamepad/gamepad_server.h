#pragma once

#include <cgv/gui/key_event.h>
#include <cgv/gui/throttle_event.h>
#include <cgv/gui/stick_event.h>
#include <cgv/gui/window.h>
#include <cgv/signal/signal.h>
#include <cgv/signal/bool_signal.h>
#include <gamepad/gamepad.h>

#include "lib_begin.h"

namespace cgv {
	namespace gui {
		/// gamepad key events use the key codes defined in gamepad::GamepadKeys
		class CGV_API gamepad_key_event : public cgv::gui::key_event
		{
		protected:
			/// store id of gamepad
			void* device_handle;
			/// public access to game state allows skipping of library dependency
			const gamepad::gamepad_state& state;
		public:
			/// construct a key event from its textual description 
			gamepad_key_event(void* _device_handle, const gamepad::gamepad_state& _state, unsigned short _key = 0, KeyAction _action = KA_PRESS, unsigned char _char = 0, double _time = 0);
			/// return the device id, by default returns 0
			void* get_device_handle() const { return device_handle; }
			/// access to current gamepad state
			const gamepad::gamepad_state& get_state() const { return state; }
			/// write to stream
			void stream_out(std::ostream& os) const;
		};
		
		/// gamepad extension of throttle events 
		class CGV_API gamepad_throttle_event : public cgv::gui::throttle_event
		{
		protected:
			/// store id of gamepad
			void* device_handle;
			/// public access to game state allows skipping of library dependency
			const gamepad::gamepad_state& state;
		public:
			/// construct a key event from its textual description 
			gamepad_throttle_event(void* _device_handle, gamepad::gamepad_state& _state,
				float _x, float _dx, unsigned _player_index = 0, unsigned _controller_index = 0, unsigned _throttle_index = 0, double _time = 0);
			/// return the device id, by default returns 0
			void* get_device_handle() const { return device_handle; }
			/// access to current gamepad state
			const gamepad::gamepad_state& get_state() const { return state; }
			/// write to stream
			void stream_out(std::ostream& os) const;
		};

		/// gamepad extension of stick events 
		class CGV_API gamepad_stick_event : public cgv::gui::stick_event
		{
		protected:
			/// store id of gamepad
			void* device_handle;
			/// public access to game state allows skipping of library dependency
			const gamepad::gamepad_state& state;
		public:
			/// construct a key event from its textual description 
			gamepad_stick_event(void* _device_handle, gamepad::gamepad_state& _state,
				StickAction _action, float _x, float _y, float _dx, float _dy,
				unsigned _player_index = 0, unsigned _controller_index = 0, unsigned _stick_index = 0, double _time = 0);
			/// return the device id, by default returns 0
			void* get_device_handle() const;
			/// access to current gamepad state
			const gamepad::gamepad_state& get_state() const;
			/// write to stream
			void stream_out(std::ostream& os) const;
		};

		/// flags to define which events should be generated by server
		enum GamepadEventTypeFlags
		{
			GPE_NONE = 0,
			GPE_DEVICE = 1,
			GPE_KEY = 2,
			GPE_THROTTLE = 4,
			GPE_STICK = 8,
			GPE_STICK_KEY = 16, // whether stick touch and press actions should be translated to key events
			GPE_ALL = 31
		};

		class CGV_API gamepad_server
		{
		protected:
			GamepadEventTypeFlags event_flags;
			double last_device_scan;
			double device_scan_interval;
			std::vector<gamepad::gamepad_state> last_states;
			std::vector<void*> device_handles;
		public:
			/// construct server with default configuration
			gamepad_server();
			/// query the currently set event type flags
			GamepadEventTypeFlags get_event_type_flags() const { return event_flags; }
			/// set the event type flags of to be emitted events
			void set_event_type_flags(GamepadEventTypeFlags flags);
			/// set time interval in seconds to check for device connection changes
			void set_device_scan_interval(double duration);
			/// check enabled gamepad devices for new events and dispatch them through the on_event signal
			void check_and_emit_events(double time);
			/// signal emitted to dispatch events
			cgv::signal::bool_signal<cgv::gui::event&> on_event;
			/// signal emitted to notify about device changes, first argument is device handle and second whether device is connected or disconnected
			cgv::signal::signal<void*, bool> on_device_change;
		};

		/// return a reference to gamepad server singleton
		extern CGV_API gamepad_server& ref_gamepad_server();

		/// connect the gamepad server to the given window or the first window of the application, if window is not provided
		extern CGV_API void connect_gamepad_server(cgv::gui::window_ptr w = cgv::gui::window_ptr());
	}
}

#include <cgv/config/lib_end.h>
