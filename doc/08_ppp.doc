// This file is for Doxygen input. It is not compiled.

using namespace cgv;

/*! \page ppp ppp, the pre-pre-processor

\section intro Introduction to ppp

ppp was originally developed to extend the functionallity of the C++
preprocessor. This was done by embedding special commands inside a
preheader file with extension *.ph and then transforming the preheader
to a real header file interpreting the special commands. ppp (speek tripel-p) 
has its name from the three 'p's in the word pre-preprocessor.

The embedding of special commands inside a text document proved useful
for other applications too and in this way ppp was also used to transform
template files based on previously collected information into target files.
This template transformation process is applied for
- makefile generation
- source code generation for type reflection
as described in later sections.

\section motivation Motivation for usage of another preprocessor

If possible it would be best to avoid custom build tools whereever 
possible. ppp has been implemented to develop repetitive code needed in template
programming, where looping is necessary. The C++ pre-processor can be
used for this purpose also but the resulting code is incomprehensible, it
does not work together with debuggers and documentation tools like doxygen
do neither work.

\section user_guide User Guide

\subsection Command Line and Custom Build Rules

The source code of ppp is located in \c "$(CGV_DIR)/tool/ppp". A precompiled
executable is provided for windows and located in \c "$(CGV_DIR)/bin/ppp.exe".
ppp can be invoked in two ways:
- to process one file into another
\code
ppp.exe [-name=value]* source-file target-file
\endcode
- to get information from one file and use this to transform one or several
   template files into target files.
\code
ppp.exe [-name=value]* source-file [template-file target-file]+
\endcode
In both cases one can specify variable definitions marked by a minus sign.
When several template files are transformed to several target files, the
variable definitions are parsed once before each processing of a template
file.

Used extensions for ppp input files:
- \c ".ph" ...  for pre-header files that are used to generate code
- \c ".ppp" ... files that are used solely to configure ppp. The standard
                ppp configuration file is located in \c "<cgv/config/ppp.ppp>".
- \c ".hh" ...  header files of classes that uses the automatic type reflection
                mechanism
- \c ".pj" ...  project files used for make file generation
- \c ".tm" ...  template files

For the visual studio development environment, custom build rules are defined
for ".ph", ".hh" and ".pj" files. The custom rule files are located in
the folder \c "$(CGV_DIR)/make/vs".

\subsection Example Example Pre-Header File and Generated Header

A simple example of the usage of ppp is given in the header abst_signal.ph 
which is located in the namespace cgv::base. It contains a templated class 
signature representing an arbitrary signature of a functor.

\c cgv/base/abst_signal.ph:

\dontinclude abst_signal.ph
\skip #pragma
\line @exclude
\skip template
\until };
\until \@}

All ppp commands are preceeded by a @-symbol. This example includes three ppp commands:
- the \c \@exclude-command includes the proceeding files but does not add a 
  corresponding include directive in the target file (what is done by the
  \c \@include-command). The included file ppp.ppp defines
  several global ppp-variables, one of them is \c N_ARG .
- the list command \c \@[...] repeats a string, i.e. \c "typename T1", into a list
  separated for example by ", ". In each entry numbers in the string are incremented.
- the \c \@(...) simply writes the value of a ppp internal variable to the target file.
- the \c \@for-commands iterate everything within the ppp-block markers @{ and @}
  using the loop variables \c i and \c j.

For completeness we give the ppp configuration file ppp.ppp:

\c cgv/config/ppp.ppp:

\include ppp.ppp

Here we see also the \c \@define-command, which is used to set ppp-variables. Finally,
we show the header generated by ppp when applied to the header abst_signal.ph

\c cgv/base/abst_signal.h:

\dontinclude abst_signal.h
\skip template
\until #include

\subsection command-syntax Syntax of ppp commands

All ppp-commands are of the following structure:

\verbatim
@[command-word] [open-parenthesis expressions close-parenthesis][@{ ... @}]
\endverbatim

All commands start with the @-symbol. Most of them are followed by a command word like for, if, else, ...
The command word or if not present the @ symbol is typically followed by one or several expressions enclosed
in a pair of parentheses and separated by ';'. The expressions are explained in the next subsections and are 
very similar to C++ operator expressions. After the expression list, some commands are followed by a source 
code block that is enclosed by the parentheses @{ and @}. 
 
The command syntax is defined in the source file command_token.cxx in the get_command_info function:

\dontinclude command_token.cxx
\skip };
\until return
\until }

The different columns define
- the meaning of the command as command token enum
- the command word or if no command word is present, the open parenthesis
- the length of the command word
- the number of symbols in the command word. If this is zero, no command word is present. 
- the number of expressions given within the parentheses. If this is 0, no parenthesis are used. 
- a boolean whether a source code block follows the command
- a boolean whether the expression list really contains expressions
- the list of possible open parentheses
- the list of possible closing parentheses in the same order

The semantics of the commands is as follows
- \verbatim
@define(expr)
\endverbatim ... the define command takes one expression and no source-code-block and simply 
evaluates the expression
- \verbatim
@for (init-expr; cond-expr; post-loop-expr) @{ source-code-block @}
\endverbatim ... the for command takes three expressions and a \c source-code block. Its semantics is 
identical to the C++-for command. In each iteration of the for loop the \c source-code-block is 
processed and output is generated into the generated header file.
- \verbatim
@if(cond-expr-1)@{ source-block-1 @}@elif(cond-expr-2)@{ source-block-2 @}@else@{ source-block-3 @}
\endverbatim ... the if, elif and else commands work similar to the preprocessor \#if, \#elif, \#else.
- \verbatim
@(expr) or @"expr"
\endverbatim ... the eval and string commands take one expression in different parenthesis. Both
evaluate their expressions and write the result into the generated header file. The string command
adds C++-string signs around the evaluated expression.
- \verbatim
@[begin-expr;sep-expr;end-expr]
\endverbatim ... the list command takes three expressions. The \c begin-expr and \c end-expr are both
evaluated and the result interpreted as string. The two strings may differ only in integer numbers, i.e.
the strings \c begin-string and \c end-string must be of the forms 
\verbatim begin_string = s0.nb1.s1.nb2 ... sm and end_string = s0.ne1.s1.ne2 ... sm\endverbatim with
strings \c si and integer numbers \c nbi and \c nei. All differences \c nei-nbi must be equal. The list
expression finally generates a list of \c nei-nbi entries of the form \c s0.n1.s1.n2...sm, separated by
expression \c end-expr evaluated and interpreted as string. This list is written to the generated header.
The command \verbatim @["T0 v0"; ","; "T3 v3"] \endverbatim will generated the output 
\verbatim T0 v0, T1 v1, T2 v2, T3 v3 \endverbatim.
- \verbatim
@[include|exclude|insert] [<|"|(]cgv/config/ppp.ppp[>|"|)]
\endverbatim ... include, exclude and insert commands make ppp include the given 
specified files recursively. The argument can be enclosed either in \c <>, \c ""
or \c (). In the first two cases it is not parsed and the file name lookup is
identical to the file name lookup of the compiler. When using \c (), the expression
is evaluated and the resulting string is used as file name.
Only in case of \c insert output is generated from 
the included files. The \c include command generates an \c \#include directive, 
where the extension is always converted to \c ".h". The \c exclude command does
not create any output. ppp searches for includes in the paths defined in the
directories specified in the environment variables \c INCLUDE, \c CGV_DIR and 
\c CGV_ROOT. It is therefore important to set the environment variable \c INCLUDE
appropriately.
- \verbatim
@cout(expr)
\endverbatim ... evaluate the expression, convert to string and stream out to the
cout stream
- \verbatim
@cin(ref-expr)
\endverbatim ... read a line from the cin stream, extract integer or string value, 
evaluate the reference expression and set the resulting reference to the input
value.
- \verbatim
@error(nr-expr; str-expr)
\endverbatim ... generates an error with number \c nr-expr and message
\c str-expr.
- \verbatim
@warning(nr-expr; str-expr)
\endverbatim ... generates a warning with number \c nr-expr and message
\c str-expr.
- \verbatim
@system(str-expr; ref-expr)
\endverbatim ... call a system command with the C-system function. \c str-expr
is the command line for the system call and \c ref-expr a reference expression
to store the result of the system call.
- \verbatim
@exit(nr-expr)
\endverbatim ... exits ppp with the error code to which \c nr-expr evaluates.

\subsection expression-syntax Syntax of ppp expressions
The ppp expressions are based on a variant data type that is used for all variables.
It can assume the types bool, int, string, list and map, where the map key is of type
string. Prototypes for the different types are available in the predefined variables
UNDEF, BOOL, INT, STRING, LIST, MAP. The variant type internally also uses references and
names as types, allthough there is no access to these two types within ppp-expressions.
References are used to support assignment operators and names in the use of maps.

An expression is composed of constants, identifiers, ()-parantheses and operators.

There are integer and string constants, where strings can be delimited by "" or ''.
Special characters can be created with the C++ syntax, i.e. \\n for new line, 
\\000 for octal and \\xFF for hexadecimal representations.

The supported operators are defined in operators.cxx and composed of one or maximally
two symbols. They are unary or binary:
\dontinclude operators.cxx
\skip };
\until return
\until }

The different columns define
- command enum type
- symbol / symbol combination
- number of arguments, i.e. 1 or 2 for unary or binary operator
- operator priority
- operator evaluation precedence

The semantics of the operators extends the C++-semantics. Each operator can have 
a different semantics depending on the input types. Some more information about the
operators:
- \c '=' ... assignment operator. On left side needs to be a variable. The variable
is defined by this command if not defined before
- the logical operators convert each argument to a boolean first and always output
a boolean value.
- \c '!' ... if the C++-not operator is applied to a list or map, it returns the number
of elements.
- \c '.' ... the dot-operator works on strings and concatenates two strings, two lists,
one list and a new element or inserts key-value pairs into a map. For example
\code
@define(map = MAP.[["chair",5],["car",7]])
\endcode
defines a new map from the built in variable of type map and inserts two key-value
pairs mapping "car" to the value 7 and "chair" to 5.
- \c '[ ]' ... the []-parenthesis are used to construct lists and to access strings, 
lists and maps. In the following example a list with 4 elements is created. Then
the 7-the letter ([6]) of the first element ([0]) in the nested list of the last 
element ([3]) of the newly created list is accessed, resulting in the one character
string "_":
\code
[1,7,"test",["nested_list"]][3][0][6]
\endcode
When accessing a map, the operand inside the parenthesis can be an int or a string. 
In the following example, all accesses to the previously defined map yield the same 
result. Note that the key-value pairs are sorted in the map:
\code
@define(key="chair")
map[1], map["chair"], map[key]
\endcode
- \c '::' ... the ::-operator is used in the same way as the namespace access operator
in C++ to access map elements. The second operand must be an identifyer. In the
following example the second access to the map will yield an undefined value as
\c map["key"] is no key in any key-value pair. To use the value of \c key you need
to use the syntax \c map[key].
\code
map::chair, map::key ~~ UNDEF
\endcode
- \c '<' ... besides the regular use on string and integer values, the less operator
can be used to check if a value is a member of a list. For example
\code
"a" < ["b", "d", "a"]
\endcode
would evaluate to true.
- \c '~~' and \c '!~' ... these two special operators can be used to check whether two 
expressions have the same or different type. Typically one uses them to check whether
a variant is of a certain type or even whether an identifier has a defined value:
\code
my_id ~~ UNDEF
\endcode
- \c '?' ... unary operator checking if a file or directory exists on disk and returns 
             a boolean result
             
several operators are overloaded to provide efficient manipulation of strings:
- \c '+' / \c '-' ... if left operand is string and right one an integer \c i, the string
                    is shortened by \c i characters from the left (\c '+') or right (\c '-').
                    In the same way one can remove elements from the beginning or end of 
                    a list.
                    If the right operand is also a string, the left string is searched
                    for one of the characters in the right string and cut until the first
                    found character including this character. In case of \c '+' the left
                    string is searched and cut from the left and in case of \c '-' from 
                    the right.
- \c '*' ... applied with two string arguments \c s1 and \c s2 performs a search and replace
         on string \c s1. String \c s2 is split into two sub strings \c ss1 and \c ss2. The first
         character in s2 is assumed to be the separation symbol. For example \c "|a|A|"
         would set \c ss1 to \c "a" and \c ss2 to \c "A" and \c "@/@\\@" would set \c ss1 
         to \c "/" and \c ss2 to \c "\\". Finally, all appearances of \c ss1 in \c s1 are 
         replaced by \c ss2.
*/