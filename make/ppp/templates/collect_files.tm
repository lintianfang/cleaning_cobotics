/* collect_files is a non recursive function that collects files from an
   input directory and adds further files that are generated by rules.

	Inputs:
	- extend_collection:BOOL ... whether to extend files collected previously from a 
	                             different directory

   - input_files:LIST of STRING ... file names of input files not scanned from directories.
	                             Can be empty or undefined

	- input_directories:LIST of STRING ... directories that are scanned for source files.
	                             Can be empty or undefined

	- collect_recursive:BOOL ... whether the input directories should be scanned recursively.
	                             Can be undefined, in which case the directories are not scanned
										  recursively

	- ignore_directories:LIST of STRING ... list of directories to be ignored.
	                             Can be empty or undefined.

	- ignore_files:LIST of STRING ... list of file names to be ignored.
	                             Can be empty or undefined.

	- rules:LIST of MAP ... definition of rules that generate new files from input files.
	                        The default rules are defined at the end of <cgv/config/ppp/make.ppp>.
									Each rule can define the following entries:
			extensions:LIST of STRING ... list of extensions to which the rule is applied, where
			                  the extensions do not contain the dot
			folder:STRING ... folder into which the files are sorted in the output of this function.
			                  If the folder entry is undefined, it defaults to "root".
			rules:LIST of MAP ... list of rules that describe how to derive the file name of 
			                  newly created files. If the rules entry is undefined, no new
									files are generated. Each map can have the following entries.
					extension:STRING ... extension without dot of the newly created file that is 
					                     used to sort the new file into the folders defined in the 
												output of this function. This must be defined.
				   keep_extension:BOOL ... if defined and set to true, the extension of the old
					                     file name will be kept in the new file name and extended
												by the new extension.
												Can be undefined resulting in the value false.
					suffix:STRING ... the new file name extends the old file name by the suffix, which
					                  is added before the new extension.
											Can be empty or undefined.
					path:STRING ... if specified, the path, where the new file should be located.
					                Can be empty or undefined.

	Outputs:
	- folder_map:MAP of LIST of STRING ... maps each folder name to a list of file names
	                                       contained in this folder. The folder name
														"root" is used for all files that are not mapped
														to a folder name by their rules
	- folder_list:LIST of STRING ... a list of all folder names into which files have been
	                                 collected
*/
@// init the output variables if not in extension mode
@define(extension_mode=0)
@if(extend_collection !~ UNDEF)@{
	@define(extension_mode=extend_collection)
@}
@if(!extension_mode)@{
	@define(folder_map=MAP)
	@define(folder_list=[])
@}
@// update the input and ignored file and directory names
@if(input_files ~~ LIST)@{
	@for(fi=0; fi<(!input_files); ++fi)@{
		@define(input_files[fi] = input_files[fi]*'|\\|/|')
	@}
@}
@if(input_directories ~~ LIST)@{
	@for(di=0; di<(!input_directories); ++di)@{
		@define(input_directories[di] = input_directories[di]*'|\\|/|')
	@}
@}
@if(ignore_files ~~ LIST)@{
	@for(fi=0; fi<(!ignore_files); ++fi)@{
		@define(ignore_files[fi] = ignore_files[fi]*'|\\|/|')
	@}
@}
@if(ignore_directories ~~ LIST)@{
	@for(di=0; di<(!ignore_directories); ++di)@{
		@define(ignore_directories[di] = ignore_directories[di]*'|\\|/|')
	@}
@}
@// check whether input directories should be scanned recursively
@define(recurse=0)
@if(collect_recursive !~ UNDEF)@{
	@if(collect_recursive)@{
		@define(recurse=1)
	@}
@}
@// emulate while loop which terminates when no more input_directories or input_files 
@// need to be processed
@define(finished = 0)
@for(0;!finished;0)@{
	@// check for termination
	@define(finished=2)
	@if(input_directories !~ LIST)@{
		@define(finished=finished-1)
	@}
	@else@{
		@if((!input_directories) == 0)@{
			@define(finished=finished-1)
		@}
	@}
	@if(input_files !~ LIST)@{
		@define(finished=finished-1)
	@}
	@else@{
		@if((!input_files) == 0)@{
			@define(finished=finished-1)
		@}
	@}
	@define(finished = (finished == 0))
	input files = @(input_files)
	input_directories = @(input_directories)
	@// if not terminated execute body of while loop
	@define(new_input_files=[])
	@if(!finished)@{
		@// iterate all rules to scan the input directories and to classify the input files
		@for(ri=0; ri < !rules; ++ri)@{
			@// iterate the extensions
			@define(new_files=[])
			@for (ei=0; ei < !(rules[ri]::extensions); ++ei)@{
				@if(input_directories ~~ LIST)@{
					@for(di=0; di<!input_directories; ++di)@{
						@dir(input_directories[di];"*.".(rules[ri]::extensions)[ei];recurse;new_files)
					@}
				@}
				@if(input_files ~~ LIST)@{
					@for(fi=0; fi<!input_files; ++fi)@{
						@define(ext=input_files[fi]+((!(input_files[fi]-'.'))+1))
						@if(ext == (rules[ri]::extensions)[ei])@{
							@// determine file name of the new file
							@define(new_file_name=input_files[fi]+(!(input_files[fi]-'/')+1))
							@define(new_files=new_files.[[new_file_name."", input_files[fi]]])
						@}
					@}
				@}
			@}
			@// check for to be ignored files
			@if(ignore_files ~~ LIST)@{
				@for(ifi=0; ifi<!ignore_files; ++ifi)@{
					@for(nfi=0; nfi<!new_files; ++nfi)@{
						@// if to be ignored file found
						@if( (new_files[nfi][0] == ignore_files[ifi]) |
							  (new_files[nfi][1] == ignore_files[ifi]) )@{
								  @// remove from list and decrement new file index
								  @define(new_files = (new_files-((!new_files)-nfi)).(new_files+(nfi+1)))
								  @define(nfi = nfi-1)
						@}
					@}
				@}
			@}
			@// check for to be ignored directories
			@if(ignore_directories ~~ LIST)@{
				@for(idi=0; idi<!ignore_directories; ++idi)@{
					@define(dir_length = !(ignore_directories[idi]))
					@for(nfi=0; nfi<!new_files; ++nfi)@{
						@// if to be ignored file found
						@define(nf_length=!(new_files[nfi][1]))
						@if( (nf_length > dir_length) &
						     ((new_files[nfi][1]-(nf_length-dir_length)) == ignore_directories[idi]) )@{
								  @// remove from list and decrement new file index
								  @define(new_files = (new_files-((!new_files)-nfi)).(new_files+(nfi+1)))
								  @define(nfi = nfi-1)
						@}
					@}
				@}
			@}
			@// if new files found
			@if((!new_files) > 0)@{
				@// add new files to folder defined in rule
				@define(folder_name="root")
				@if(rules[ri]::folder !~ UNDEF)@{
					@define(folder_name=rules[ri]::folder)
				@}
				@if(folder_map[folder_name] ~~ UNDEF)@{
					@define(folder_list = folder_list.[folder_name.""])
					@define(folder_map[folder_name.""] = [])
				@}
				@for(fi=0; fi < !new_files; ++fi)@{
					@if(!(new_files[fi][1] < folder_map[folder_name]))@{
						@define(folder_map[folder_name] = folder_map[folder_name].[new_files[fi][1].""])
					@}
				@}
				@// check for rules
				@if(rules[ri]::rules !~ UNDEF)@{
					@// iterate rules
					@for(rj=0; rj<!(rules[ri]::rules); ++rj)@{
						@define(rule=(rules[ri]::rules)[rj])
						@// iterate all new files
						@for(fi=0; fi<!new_files; ++fi)@{
							@// derive new file name
							@define(new_file_name=new_files[fi][1])
							@if(rule::path !~ UNDEF)@{
								@define(new_file_name=(rule::path*'|\\|/|').'/'.new_files[fi][0])
							@}
							@if(rule::keep_extension ~~ UNDEF)@{
								@define(new_file_name=new_file_name-'.')
							@}
							@else@{
								@if(!(rule::keep_extension))@{
									@define(new_file_name=new_file_name-'.')
								@}
							@}
							@if(rule::suffix !~ UNDEF)@{
								@define(new_file_name=new_file_name.(rule::suffix))
							@}
							@define(new_file_name=new_file_name.'.'.(rule::extension))
							@// add new file to its folder
							@define(new_input_files = new_input_files.[new_file_name.""])
						@}
					@}
				@}
			@}
		@}
	@}
	@define(input_directories=[])
	@define(input_files=new_input_files)
@}